-- WARNING: Do NOT edit the input and output ports in this file in a text
-- editor if you plan to continue editing the block that represents it in
-- the Block Editor! File corruption is VERY likely to occur.

-- Copyright (C) 1991-2003 Altera Corporation
-- Any  megafunction  design,  and related netlist (encrypted  or  decrypted),
-- support information,  device programming or simulation file,  and any other
-- associated  documentation or information  provided by  Altera  or a partner
-- under  Altera's   Megafunction   Partnership   Program  may  be  used  only
-- to program  PLD  devices (but not masked  PLD  devices) from  Altera.   Any
-- other  use  of such  megafunction  design,  netlist,  support  information,
-- device programming or simulation file,  or any other  related documentation
-- or information  is prohibited  for  any  other purpose,  including, but not
-- limited to  modification,  reverse engineering,  de-compiling, or use  with
-- any other  silicon devices,  unless such use is  explicitly  licensed under
-- a separate agreement with  Altera  or a megafunction partner.  Title to the
-- intellectual property,  including patents,  copyrights,  trademarks,  trade
-- secrets,  or maskworks,  embodied in any such megafunction design, netlist,
-- support  information,  device programming or simulation file,  or any other
-- related documentation or information provided by  Altera  or a megafunction
-- partner, remains with Altera, the megafunction partner, or their respective
-- licensors. No other licenses, including any licenses needed under any third
-- party's intellectual property, are provided herein.


-- Generated by Quartus II Version 2.2 (Build Build 191 03/31/2003)
-- Created on Wed Nov 19 12:02:12 2003

LIBRARY ieee;
USE ieee.std_logic_1164.all;


--  Entity Declaration

ENTITY tlv5637 IS
	-- {{ALTERA_IO_BEGIN}} DO NOT REMOVE THIS LINE!
	PORT
	(
		clk : IN STD_LOGIC;
		reset : IN STD_LOGIC;
		update_DACs : IN STD_LOGIC;
		dac1A_data : IN STD_LOGIC_VECTOR(11 downto 0);
		dac1B_data : IN STD_LOGIC_VECTOR(11 downto 0);
		dac2A_data : IN STD_LOGIC_VECTOR(11 downto 0);
		dac2B_data : IN STD_LOGIC_VECTOR(11 downto 0);
		clk_en : IN STD_LOGIC;
		sync : OUT STD_LOGIC;
		update_done : out std_logic;
		test1 : OUT STD_LOGIC;
		test2 : OUT STD_LOGIC;
		test3 : OUT STD_LOGIC;
		test4 : OUT STD_LOGIC;
		data1 : OUT STD_LOGIC;
		data2 : OUT STD_LOGIC;
		sck : OUT STD_LOGIC
	);
	-- {{ALTERA_IO_END}} DO NOT REMOVE THIS LINE!
	
END tlv5637;


--  Architecture Body

ARCHITECTURE a OF tlv5637 IS

	TYPE STATE_TYPE IS (
	idle,
	sync_l,
	sync_h,
	data_l,
	data_h,
	data_end,
	next_tx			
	);
	
	TYPE STATE_MAIN IS (
	Midle,
	Mwait_config,
	Mwait_DAC_A,
	Mwait_DAC_B,
	Mready		
	);
	
	
	SIGNAL state: STATE_TYPE;
	SIGNAL Mstate: STATE_MAIN;
    signal shift_count : integer range 0 to 35;
    signal shiftreg,
			dac1_data,
			dac2_data : std_logic_vector (15 downto 0);
    signal shiftreg_2 : std_logic_vector (15 downto 0);
    signal  shift_enable,
		 	shifter_load,
			sck_temp,sck_buffer,
			sync_temp,
		    shift_reset,
			data_temp,
			data_2_temp,
		    stop_shift,
			en_conv	 : std_logic ;
			
	constant DAC_CONFIG : std_logic_vector (11 downto 0) := "000000001001" ;			
BEGIN
 

--***********************************************************************************************************************************************
--*******************************************	main control state machine	*********************************************************************
--***********************************************************************************************************************************************

PROCESS (clk,reset)
	BEGIN
		IF reset = '1' THEN
			Mstate <= Midle;
		ELSIF clk'EVENT AND clk = '1' THEN	
			if clk_en = '1' then
				CASE Mstate IS
					WHEN Midle =>
						IF update_DACs = '1' THEN
							Mstate <=Mwait_config;
						END IF;
						
					when Mwait_config =>
						IF state = next_tx THEN
							Mstate <=Mwait_DAC_A;
						END IF;
						
					when Mwait_DAC_A =>	
						IF state = next_tx THEN
							Mstate <=Mwait_DAC_B;
						END IF;
						
					when Mwait_DAC_B =>  
						IF state = next_tx THEN
							Mstate <=Mready;
						END IF;
						
					when Mready =>
						IF update_DACs = '0' THEN
							Mstate <=Midle;
						END IF;
					



				END CASE;
			end if;
		END IF;
	END PROCESS;



	WITH Mstate  SELECT
		en_conv 	<=		'0' when Midle,
							'1' when Mwait_config,
							'1' when Mwait_DAC_A,							
							'1' when Mwait_DAC_B,
							'0' when Mready;
					



WITH Mstate  SELECT
		update_done 	<=	'1' when Midle,
							'1' when Mwait_config,
							'1' when Mwait_DAC_A,							
							'1' when Mwait_DAC_B,
							'0' when Mready;
				

WITH Mstate  SELECT
		dac1_data	<=		"1001" & DAC_CONFIG when Midle,
							"1001" & DAC_CONFIG when Mwait_config,
							"0001" & dac1A_data when Mwait_DAC_A,							
							"1000" & dac1B_data when Mwait_DAC_B,
							"1000" & dac1B_data when Mready;
							
							
WITH Mstate  SELECT
		dac2_data	<=		"1001" & DAC_CONFIG when Midle,
							"1001" & DAC_CONFIG when Mwait_config,
							"0001" & dac2A_data when Mwait_DAC_A,							
							"1000" & dac2B_data when Mwait_DAC_B,
							"1000" & dac2B_data when Mready;

--***********************************************************************************************************************************************
--*******************************************	data transfer state machine	*********************************************************************
--***********************************************************************************************************************************************









	PROCESS (clk,reset)
	BEGIN
		IF reset = '1' THEN
			state <= idle;
		ELSIF clk'EVENT AND clk = '1' THEN	
			if clk_en = '1' then
				CASE state IS
					WHEN idle =>
						IF en_conv = '1' THEN
							state <=sync_l;
						END IF;
					when sync_l =>
							state<=sync_h;
					when sync_h =>	
							state<=data_l;
					when data_l =>  
						if stop_shift = '1' then
							state <= data_end;
						else	
							state<=data_h;
						end if;	
					when data_h =>
							state<=data_l; 
					when data_end =>
							state<=next_tx;
					when next_tx=>
							state<=idle;
					



				END CASE;
			end if;
		END IF;
	END PROCESS;

	WITH state SELECT
		shift_reset 	<=	'1' when idle,
							'1' when sync_l,
							'1' when sync_h,							
							'0' when data_l,
							'0' when data_h,
							'0' when data_end,
							'0' when next_tx;
							
							
	WITH state SELECT
		sck_temp        <=  '0' when idle,
							'0' when sync_l,
							'0' when sync_h,							
							'0' when data_l,
							'1' when data_h,
							'0' when data_end,
							'0' when next_tx;
		 
WITH state SELECT
		shift_enable    <=  '0' when idle,
							'0' when sync_l,
							'0' when sync_h,							
							'1' when data_l,
							'1' when data_h,
							'0' when data_end,
							'0' when next_tx;
							
	
							
	WITH state SELECT
	shifter_load        <=  '0' when idle,
							'1' when sync_l,
							'1' when sync_h,							
							'0' when data_l,
							'0' when data_h,
							'0' when data_end,
							'0' when next_tx;
							
	WITH state SELECT
	sync_temp          <=   '1' when idle,
							'1' when sync_l,
							'1' when sync_h,							
							'0' when data_l,
							'0' when data_h,
							'1' when data_end,
							'1' when next_tx;
		
		
		

process(clk,shift_count)
begin
	if clk'event and clk='1' then
		if clk_en = '1' then
			if shift_reset='1' or reset = '1'  then
	            shift_count<=0;	
				stop_shift <= '0';
			elsif  stop_shift='0' then
					shift_count <=shift_count+1;		
			end if;
		end if;
	end if;
   	if shift_count = 34 then	
		stop_shift<='1';
	else
		stop_shift<='0';
	end if;
		end process;
		
		
		
							
process(clk)
begin
if clk'event and clk='0' then
	sck_buffer<=sck_temp;
	sync<=sync_temp; 
--	data<=data_temp;
end if;
end process;

	sck<=sck_buffer;
process(clk)
begin
if clk'event and clk='1' then
	data1<=data_temp; 
	data2<=data_2_temp; 
	end if;
end process;








Process (clk)
	begin
	if clk'event and clk='1' then
		if clk_en = '1' then
		 	if shifter_load = '1' then
				shiftreg <= dac1_data;
				shiftreg_2 <= dac2_data;
			elsif sck_buffer='1' then
			   	if (shift_enable) = '1'  THEN
			    	shiftreg(15 downto 0) <= shiftreg (14 downto 0) & '0';
					shiftreg_2(15 downto 0) <= shiftreg_2 (14 downto 0) & '0';
					data_temp <=shiftreg(15);
					data_2_temp <=shiftreg_2(15);
				end if;
			end if;
		end if;
	end if;
end process;

	

test1<= en_conv;
test2<=stop_shift;
test3<='1';
test4<=shift_enable;








END a;




